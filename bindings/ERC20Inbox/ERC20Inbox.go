// This file was generated by seer: https://github.com/G7DAO/seer.
// seer version: 0.1.3
// seer command: seer evm generate --package ERC20Inbox --cli --struct ERC20Inbox
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package ERC20Inbox

import (
	"errors"
	"math/big"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// ERC20InboxMetaData contains all meta data concerning the ERC20Inbox contract.
var ERC20InboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDataSize\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDataLength\",\"type\":\"uint256\"}],\"name\":\"DataTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientSubmissionCost\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"L1Forked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"NotAllowedOrigin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOrigin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotRollupOrOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RetryableData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"AllowListAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"AllowListEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calculateRetryableSubmissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenTotalFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contractISequencerInbox\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2Message\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2MessageFromOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contractISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"val\",\"type\":\"bool[]\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowListEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenTotalFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unsafeCreateRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60e0604052306080524660c05234801561001857600080fd5b5060405161244f38038061244f8339810160408190526100379161003f565b60a052610058565b60006020828403121561005157600080fd5b5051919050565b60805160a05160c0516123a56100aa600039600081816103820152610c4e0152600081816102ba015281816103e10152818161041d0152818161158c01526115cc0152600061069801526123a56000f3fe608060405234801561001057600080fd5b506004361061012c5760003560e01c8063a66b327d116100ad578063e3de72a511610071578063e3de72a51461028f578063e78cea92146102a2578063e8eb1dc3146102b5578063ee35f327146102dc578063efeadb6d146102ef57600080fd5b8063a66b327d1461021d578063b75436bb14610233578063b79092fd14610246578063b9b9a68814610259578063babcc5391461026c57600080fd5b8063549e8426116100f4578063549e8426146101ab5780635c975abb146101be5780638456cb59146101c95780638a631aa6146101d15780638b3240a0146101e457600080fd5b80631fe927cf1461013157806322bd5c1c146101575780633f4ba83a1461017b578063485cc955146101855780635075788b14610198575b600080fd5b61014461013f366004611b8f565b610302565b6040519081526020015b60405180910390f35b60665461016b90600160a01b900460ff1681565b604051901515815260200161014e565b6101836104a5565b005b610183610193366004611be5565b6105e5565b6101446101a6366004611c1e565b610844565b6101446101b9366004611c9a565b610931565b60335460ff1661016b565b6101836109c6565b6101446101df366004611d49565b610b03565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03165b60405161014e9190611dbb565b61014461022b366004611dcf565b600092915050565b610144610241366004611b8f565b610bd7565b610144610254366004611df1565b610cd4565b610144610267366004611c9a565b610db4565b61016b61027a366004611e0a565b60676020526000908152604090205460ff1681565b61018361029d366004611f12565b610e3a565b606554610210906001600160a01b031681565b6101447f000000000000000000000000000000000000000000000000000000000000000081565b606654610210906001600160a01b031681565b6101836102fd366004611fd3565b6110ba565b600061031060335460ff1690565b156103365760405162461bcd60e51b815260040161032d90611ff0565b60405180910390fd5b606654600160a01b900460ff16801561035f57503260009081526067602052604090205460ff16155b1561037f5732604051630f51ed7160e41b815260040161032d9190611dbb565b467f0000000000000000000000000000000000000000000000000000000000000000146103bf5760405163c6ea680360e01b815260040160405180910390fd5b3332146103df5760405163feb3d07160e01b815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000082111561044957604051634634691b60e01b8152600481018390527f0000000000000000000000000000000000000000000000000000000000000000602482015260440161032d565b6000610470600333868660405161046192919061201a565b60405180910390206000611299565b60405190915081907fab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c90600090a29392505050565b6065546040805163cb23bcb560e01b815290516000926001600160a01b03169163cb23bcb5916004808301926020929190829003018186803b1580156104ea57600080fd5b505afa1580156104fe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610522919061202a565b9050336001600160a01b038216146105da576000816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561056f57600080fd5b505afa158015610583573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105a7919061202a565b9050336001600160a01b038216146105d857338282604051630739600760e01b815260040161032d93929190612047565b505b6105e261147e565b50565b600054610100900460ff166106005760005460ff1615610608565b61060861150b565b61066b5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161032d565b600054610100900460ff1615801561068d576000805461ffff19166101011790555b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016141561071b5760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b606482015260840161032d565b610725838361151c565b60655460408051631c2eb17b60e31b815290516000926001600160a01b03169163e1758bd8916004808301926020929190829003018186803b15801561076a57600080fd5b505afa15801561077e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a2919061202a565b60655460405163095ea7b360e01b81526001600160a01b039182166004820152600019602482015291925082169063095ea7b390604401602060405180830381600087803b1580156107f357600080fd5b505af1158015610807573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061082b919061206a565b5050801561083f576000805461ff00191690555b505050565b600061085260335460ff1690565b1561086f5760405162461bcd60e51b815260040161032d90611ff0565b606654600160a01b900460ff16801561089857503260009081526067602052604090205460ff16155b156108b85732604051630f51ed7160e41b815260040161032d9190611dbb565b6001600160401b038811156108e05760405163107c527b60e01b815260040160405180910390fd5b61092560033360008b8b8b8b6001600160a01b03168b8b8b60405160200161090f989796959493929190612087565b6040516020818303038152906040526000611588565b98975050505050505050565b600061093f60335460ff1690565b1561095c5760405162461bcd60e51b815260040161032d90611ff0565b606654600160a01b900460ff16801561098557503260009081526067602052604090205460ff16155b156109a55732604051630f51ed7160e41b815260040161032d9190611dbb565b6109b78b8b8b8b8b8b8b8b8b8b611650565b9b9a5050505050505050505050565b6065546040805163cb23bcb560e01b815290516000926001600160a01b03169163cb23bcb5916004808301926020929190829003018186803b158015610a0b57600080fd5b505afa158015610a1f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a43919061202a565b9050336001600160a01b03821614610afb576000816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b815260040160206040518083038186803b158015610a9057600080fd5b505afa158015610aa4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac8919061202a565b9050336001600160a01b03821614610af957338282604051630739600760e01b815260040161032d93929190612047565b505b6105e2611704565b6000610b1160335460ff1690565b15610b2e5760405162461bcd60e51b815260040161032d90611ff0565b606654600160a01b900460ff168015610b5757503260009081526067602052604090205460ff16155b15610b775732604051630f51ed7160e41b815260040161032d9190611dbb565b6001600160401b03871115610b9f5760405163107c527b60e01b815260040160405180910390fd5b610bcc60033360018a8a8a6001600160a01b03168a8a8a60405160200161090f97969594939291906120cd565b979650505050505050565b6000610be560335460ff1690565b15610c025760405162461bcd60e51b815260040161032d90611ff0565b606654600160a01b900460ff168015610c2b57503260009081526067602052604090205460ff16155b15610c4b5732604051630f51ed7160e41b815260040161032d9190611dbb565b467f000000000000000000000000000000000000000000000000000000000000000014610c8b5760405163c6ea680360e01b815260040160405180910390fd5b610ccd60033385858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052509250611588915050565b9392505050565b6000610ce260335460ff1690565b15610cff5760405162461bcd60e51b815260040161032d90611ff0565b606654600160a01b900460ff168015610d2857503260009081526067602052604090205460ff16155b15610d485732604051630f51ed7160e41b815260040161032d9190611dbb565b33610d528161175c565b80610d5d5750323314155b15610d7057503361111161111160901b01015b6040516bffffffffffffffffffffffff19606083901b16602082015260348101849052610ccd90600c90339060540160405160208183030381529060405286611588565b6000610dc260335460ff1690565b15610ddf5760405162461bcd60e51b815260040161032d90611ff0565b606654600160a01b900460ff168015610e0857503260009081526067602052604090205460ff16155b15610e285732604051630f51ed7160e41b815260040161032d9190611dbb565b6109b78b8b8b8b8b8b8b8b8b8b61176b565b6065546040805163cb23bcb560e01b815290516000926001600160a01b03169163cb23bcb5916004808301926020929190829003018186803b158015610e7f57600080fd5b505afa158015610e93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb7919061202a565b9050336001600160a01b03821614610f6f576000816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b815260040160206040518083038186803b158015610f0457600080fd5b505afa158015610f18573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f3c919061202a565b9050336001600160a01b03821614610f6d57338282604051630739600760e01b815260040161032d93929190612047565b505b8151835114610fb05760405162461bcd60e51b815260206004820152600d60248201526c1253959053125117d253941555609a1b604482015260640161032d565b60005b83518110156110b457828181518110610fce57610fce61210c565b602002602001015160676000868481518110610fec57610fec61210c565b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002060006101000a81548160ff02191690831515021790555083818151811061103d5761103d61210c565b60200260200101516001600160a01b03167fd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a8483815181106110815761108161210c565b602002602001015160405161109a911515815260200190565b60405180910390a2806110ac81612138565b915050610fb3565b50505050565b6065546040805163cb23bcb560e01b815290516000926001600160a01b03169163cb23bcb5916004808301926020929190829003018186803b1580156110ff57600080fd5b505afa158015611113573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611137919061202a565b9050336001600160a01b038216146111ef576000816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561118457600080fd5b505afa158015611198573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111bc919061202a565b9050336001600160a01b038216146111ed57338282604051630739600760e01b815260040161032d93929190612047565b505b606660149054906101000a900460ff16151582151514156112405760405162461bcd60e51b815260206004820152600b60248201526a1053149150511657d4d15560aa1b604482015260640161032d565b60668054831515600160a01b0260ff60a01b199091161790556040517f16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb39061128d90841515815260200190565b60405180910390a15050565b600080606560009054906101000a90046001600160a01b03166001600160a01b031663e1758bd86040518163ffffffff1660e01b815260040160206040518083038186803b1580156112ea57600080fd5b505afa1580156112fe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611322919061202a565b90506000816001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016113529190611dbb565b60206040518083038186803b15801561136a57600080fd5b505afa15801561137e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a29190612153565b9050838110156113d15760006113b8828661216c565b90506113cf6001600160a01b038416333084611848565b505b6065546001600160a01b03166375d81e258861111161111160901b0189016040516001600160e01b031960e085901b16815260ff90921660048301526001600160a01b031660248201526044810188905260648101879052608401602060405180830381600087803b15801561144657600080fd5b505af115801561145a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bcc9190612153565b60335460ff166114c75760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b604482015260640161032d565b6033805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516115019190611dbb565b60405180910390a1565b60006115163061175c565b15905090565b600054610100900460ff166115435760405162461bcd60e51b815260040161032d90612183565b606580546001600160a01b038085166001600160a01b031990921691909117909155606680546001600160a81b0319169183169190911790556115846118a2565b5050565b60007f0000000000000000000000000000000000000000000000000000000000000000835111156115f8578251604051634634691b60e01b815260048101919091527f0000000000000000000000000000000000000000000000000000000000000000602482015260440161032d565b600061160d8686868051906020012086611299565b9050807fff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b8560405161163f9190612226565b60405180910390a295945050505050565b600061165c8587612239565b6116668b8b612258565b6116709190612258565b8410156116b9576116818587612239565b61168b8b8b612258565b6116959190612258565b604051631c102d6360e21b815260048101919091526024810185905260440161032d565b6116c28861175c565b156116d65761111161111160901b01880197505b6116df8761175c565b15610e285761111161111160901b01870196506109b78b8b8b8b8b8b8b8b8b8b61176b565b60335460ff16156117275760405162461bcd60e51b815260040161032d90611ff0565b6033805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586114f43390565b6001600160a01b03163b151590565b6000856001148061177c5750846001145b156117b057338b8b868c8c8c8c8c8b8b6040516307c266e360e01b815260040161032d9b9a99989796959493929190612270565b6001600160401b038611156117d85760405163107c527b60e01b815260040160405180910390fd5b60006118386009338e6001600160a01b03168e898f8f6001600160a01b03168f6001600160a01b03168f8f8e8e90508f8f6040516020016118239b9a999897969594939291906122f9565b60405160208183030381529060405288611588565b9c9b505050505050505050505050565b604080516001600160a01b0385811660248301528416604482015260648082018490528251808303909101815260849091019091526020810180516001600160e01b03166323b872dd60e01b1790526110b49085906118d3565b600054610100900460ff166118c95760405162461bcd60e51b815260040161032d90612183565b6118d16119a5565b565b6000611928826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166119d89092919063ffffffff16565b80519091501561083f5780806020019051810190611946919061206a565b61083f5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161032d565b600054610100900460ff166119cc5760405162461bcd60e51b815260040161032d90612183565b6033805460ff19169055565b60606119e784846000856119ef565b949350505050565b606082471015611a505760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b606482015260840161032d565b611a598561175c565b611aa55760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161032d565b600080866001600160a01b03168587604051611ac19190612353565b60006040518083038185875af1925050503d8060008114611afe576040519150601f19603f3d011682016040523d82523d6000602084013e611b03565b606091505b5091509150610bcc82828660608315611b1d575081610ccd565b825115611b2d5782518084602001fd5b8160405162461bcd60e51b815260040161032d9190612226565b60008083601f840112611b5957600080fd5b5081356001600160401b03811115611b7057600080fd5b602083019150836020828501011115611b8857600080fd5b9250929050565b60008060208385031215611ba257600080fd5b82356001600160401b03811115611bb857600080fd5b611bc485828601611b47565b90969095509350505050565b6001600160a01b03811681146105e257600080fd5b60008060408385031215611bf857600080fd5b8235611c0381611bd0565b91506020830135611c1381611bd0565b809150509250929050565b600080600080600080600060c0888a031215611c3957600080fd5b8735965060208801359550604088013594506060880135611c5981611bd0565b93506080880135925060a08801356001600160401b03811115611c7b57600080fd5b611c878a828b01611b47565b989b979a50959850939692959293505050565b6000806000806000806000806000806101208b8d031215611cba57600080fd5b8a35611cc581611bd0565b995060208b0135985060408b0135975060608b0135611ce381611bd0565b965060808b0135611cf381611bd0565b955060a08b0135945060c08b0135935060e08b013592506101008b01356001600160401b03811115611d2457600080fd5b611d308d828e01611b47565b915080935050809150509295989b9194979a5092959850565b60008060008060008060a08789031215611d6257600080fd5b86359550602087013594506040870135611d7b81611bd0565b93506060870135925060808701356001600160401b03811115611d9d57600080fd5b611da989828a01611b47565b979a9699509497509295939492505050565b6001600160a01b0391909116815260200190565b60008060408385031215611de257600080fd5b50508035926020909101359150565b600060208284031215611e0357600080fd5b5035919050565b600060208284031215611e1c57600080fd5b8135610ccd81611bd0565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715611e6557611e65611e27565b604052919050565b60006001600160401b03821115611e8657611e86611e27565b5060051b60200190565b80151581146105e257600080fd5b600082601f830112611eaf57600080fd5b81356020611ec4611ebf83611e6d565b611e3d565b82815260059290921b84018101918181019086841115611ee357600080fd5b8286015b84811015611f07578035611efa81611e90565b8352918301918301611ee7565b509695505050505050565b60008060408385031215611f2557600080fd5b82356001600160401b0380821115611f3c57600080fd5b818501915085601f830112611f5057600080fd5b81356020611f60611ebf83611e6d565b82815260059290921b84018101918181019089841115611f7f57600080fd5b948201945b83861015611fa6578535611f9781611bd0565b82529482019490820190611f84565b96505086013592505080821115611fbc57600080fd5b50611fc985828601611e9e565b9150509250929050565b600060208284031215611fe557600080fd5b8135610ccd81611e90565b60208082526010908201526f14185d5cd8589b194e881c185d5cd95960821b604082015260600190565b8183823760009101908152919050565b60006020828403121561203c57600080fd5b8151610ccd81611bd0565b6001600160a01b0393841681529183166020830152909116604082015260600190565b60006020828403121561207c57600080fd5b8151610ccd81611e90565b60ff60f81b8960f81b168152876001820152866021820152856041820152846061820152836081820152818360a18301376000910160a101908152979650505050505050565b60ff60f81b8860f81b16815286600182015285602182015284604182015283606182015281836081830137600091016081019081529695505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060001982141561214c5761214c612122565b5060010190565b60006020828403121561216557600080fd5b5051919050565b60008282101561217e5761217e612122565b500390565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b60005b838110156121e95781810151838201526020016121d1565b838111156110b45750506000910152565b600081518084526122128160208601602086016121ce565b601f01601f19169290920160200192915050565b602081526000610ccd60208301846121fa565b600081600019048311821515161561225357612253612122565b500290565b6000821982111561226b5761226b612122565b500190565b6001600160a01b038c811682528b81166020830152604082018b9052606082018a90526080820189905287811660a0830152861660c082015260e0810185905261010081018490526101406101208201819052810182905260006101608385828501376000838501820152601f909301601f19169091019091019b9a5050505050505050505050565b8b81528a60208201528960408201528860608201528760808201528660a08201528560c08201528460e08201528361010082015260006101208385828501376000929093019092019081529b9a5050505050505050505050565b600082516123658184602087016121ce565b919091019291505056fea264697066735822122049d58bdcb0b372ec561909ccbdc8a8698ab4fd67328e4915702624165ea8a6e464736f6c63430008090033",
}

// ERC20InboxABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20InboxMetaData.ABI instead.
var ERC20InboxABI = ERC20InboxMetaData.ABI

// ERC20InboxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20InboxMetaData.Bin instead.
var ERC20InboxBin = ERC20InboxMetaData.Bin

// DeployERC20Inbox deploys a new Ethereum contract, binding an instance of ERC20Inbox to it.
func DeployERC20Inbox(auth *bind.TransactOpts, backend bind.ContractBackend, _maxDataSize *big.Int) (common.Address, *types.Transaction, *ERC20Inbox, error) {
	parsed, err := ERC20InboxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20InboxBin), backend, _maxDataSize)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20Inbox{ERC20InboxCaller: ERC20InboxCaller{contract: contract}, ERC20InboxTransactor: ERC20InboxTransactor{contract: contract}, ERC20InboxFilterer: ERC20InboxFilterer{contract: contract}}, nil
}

// ERC20Inbox is an auto generated Go binding around an Ethereum contract.
type ERC20Inbox struct {
	ERC20InboxCaller     // Read-only binding to the contract
	ERC20InboxTransactor // Write-only binding to the contract
	ERC20InboxFilterer   // Log filterer for contract events
}

// ERC20InboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20InboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20InboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20InboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20InboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20InboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20InboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20InboxSession struct {
	Contract     *ERC20Inbox       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20InboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20InboxCallerSession struct {
	Contract *ERC20InboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// ERC20InboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20InboxTransactorSession struct {
	Contract     *ERC20InboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// ERC20InboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20InboxRaw struct {
	Contract *ERC20Inbox // Generic contract binding to access the raw methods on
}

// ERC20InboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20InboxCallerRaw struct {
	Contract *ERC20InboxCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20InboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20InboxTransactorRaw struct {
	Contract *ERC20InboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Inbox creates a new instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20Inbox(address common.Address, backend bind.ContractBackend) (*ERC20Inbox, error) {
	contract, err := bindERC20Inbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Inbox{ERC20InboxCaller: ERC20InboxCaller{contract: contract}, ERC20InboxTransactor: ERC20InboxTransactor{contract: contract}, ERC20InboxFilterer: ERC20InboxFilterer{contract: contract}}, nil
}

// NewERC20InboxCaller creates a new read-only instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20InboxCaller(address common.Address, caller bind.ContractCaller) (*ERC20InboxCaller, error) {
	contract, err := bindERC20Inbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxCaller{contract: contract}, nil
}

// NewERC20InboxTransactor creates a new write-only instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20InboxTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20InboxTransactor, error) {
	contract, err := bindERC20Inbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxTransactor{contract: contract}, nil
}

// NewERC20InboxFilterer creates a new log filterer instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20InboxFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20InboxFilterer, error) {
	contract, err := bindERC20Inbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxFilterer{contract: contract}, nil
}

// bindERC20Inbox binds a generic wrapper to an already deployed contract.
func bindERC20Inbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20InboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Inbox *ERC20InboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Inbox.Contract.ERC20InboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Inbox *ERC20InboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.ERC20InboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Inbox *ERC20InboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.ERC20InboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Inbox *ERC20InboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Inbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Inbox *ERC20InboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Inbox *ERC20InboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.contract.Transact(opts, method, params...)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_ERC20Inbox *ERC20InboxCaller) AllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "allowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_ERC20Inbox *ERC20InboxSession) AllowListEnabled() (bool, error) {
	return _ERC20Inbox.Contract.AllowListEnabled(&_ERC20Inbox.CallOpts)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_ERC20Inbox *ERC20InboxCallerSession) AllowListEnabled() (bool, error) {
	return _ERC20Inbox.Contract.AllowListEnabled(&_ERC20Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Inbox *ERC20InboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Inbox *ERC20InboxSession) Bridge() (common.Address, error) {
	return _ERC20Inbox.Contract.Bridge(&_ERC20Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Inbox *ERC20InboxCallerSession) Bridge() (common.Address, error) {
	return _ERC20Inbox.Contract.Bridge(&_ERC20Inbox.CallOpts)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 , uint256 ) pure returns(uint256)
func (_ERC20Inbox *ERC20InboxCaller) CalculateRetryableSubmissionFee(opts *bind.CallOpts, arg0 *big.Int, arg1 *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "calculateRetryableSubmissionFee", arg0, arg1)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 , uint256 ) pure returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) CalculateRetryableSubmissionFee(arg0 *big.Int, arg1 *big.Int) (*big.Int, error) {
	return _ERC20Inbox.Contract.CalculateRetryableSubmissionFee(&_ERC20Inbox.CallOpts, arg0, arg1)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 , uint256 ) pure returns(uint256)
func (_ERC20Inbox *ERC20InboxCallerSession) CalculateRetryableSubmissionFee(arg0 *big.Int, arg1 *big.Int) (*big.Int, error) {
	return _ERC20Inbox.Contract.CalculateRetryableSubmissionFee(&_ERC20Inbox.CallOpts, arg0, arg1)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_ERC20Inbox *ERC20InboxCaller) GetProxyAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "getProxyAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_ERC20Inbox *ERC20InboxSession) GetProxyAdmin() (common.Address, error) {
	return _ERC20Inbox.Contract.GetProxyAdmin(&_ERC20Inbox.CallOpts)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_ERC20Inbox *ERC20InboxCallerSession) GetProxyAdmin() (common.Address, error) {
	return _ERC20Inbox.Contract.GetProxyAdmin(&_ERC20Inbox.CallOpts)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_ERC20Inbox *ERC20InboxCaller) IsAllowed(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "isAllowed", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_ERC20Inbox *ERC20InboxSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _ERC20Inbox.Contract.IsAllowed(&_ERC20Inbox.CallOpts, arg0)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_ERC20Inbox *ERC20InboxCallerSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _ERC20Inbox.Contract.IsAllowed(&_ERC20Inbox.CallOpts, arg0)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ERC20Inbox *ERC20InboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) MaxDataSize() (*big.Int, error) {
	return _ERC20Inbox.Contract.MaxDataSize(&_ERC20Inbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ERC20Inbox *ERC20InboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _ERC20Inbox.Contract.MaxDataSize(&_ERC20Inbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_ERC20Inbox *ERC20InboxCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_ERC20Inbox *ERC20InboxSession) Paused() (bool, error) {
	return _ERC20Inbox.Contract.Paused(&_ERC20Inbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_ERC20Inbox *ERC20InboxCallerSession) Paused() (bool, error) {
	return _ERC20Inbox.Contract.Paused(&_ERC20Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Inbox *ERC20InboxCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Inbox *ERC20InboxSession) SequencerInbox() (common.Address, error) {
	return _ERC20Inbox.Contract.SequencerInbox(&_ERC20Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Inbox *ERC20InboxCallerSession) SequencerInbox() (common.Address, error) {
	return _ERC20Inbox.Contract.SequencerInbox(&_ERC20Inbox.CallOpts)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) CreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "createRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.CreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.CreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) DepositERC20(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "depositERC20", amount)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) DepositERC20(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.DepositERC20(&_ERC20Inbox.TransactOpts, amount)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) DepositERC20(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.DepositERC20(&_ERC20Inbox.TransactOpts, amount)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_ERC20Inbox *ERC20InboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "initialize", _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_ERC20Inbox *ERC20InboxSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Initialize(&_ERC20Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Initialize(&_ERC20Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_ERC20Inbox *ERC20InboxTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_ERC20Inbox *ERC20InboxSession) Pause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Pause(&_ERC20Inbox.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) Pause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Pause(&_ERC20Inbox.TransactOpts)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendContractTransaction", gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendContractTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendContractTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendL2Message(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendL2Message", messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2Message(&_ERC20Inbox.TransactOpts, messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2Message(&_ERC20Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendL2MessageFromOrigin(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendL2MessageFromOrigin", messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2MessageFromOrigin(&_ERC20Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2MessageFromOrigin(&_ERC20Inbox.TransactOpts, messageData)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendUnsignedTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendUnsignedTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_ERC20Inbox *ERC20InboxTransactor) SetAllowList(opts *bind.TransactOpts, user []common.Address, val []bool) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "setAllowList", user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_ERC20Inbox *ERC20InboxSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowList(&_ERC20Inbox.TransactOpts, user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowList(&_ERC20Inbox.TransactOpts, user, val)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_ERC20Inbox *ERC20InboxTransactor) SetAllowListEnabled(opts *bind.TransactOpts, _allowListEnabled bool) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "setAllowListEnabled", _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_ERC20Inbox *ERC20InboxSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowListEnabled(&_ERC20Inbox.TransactOpts, _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowListEnabled(&_ERC20Inbox.TransactOpts, _allowListEnabled)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_ERC20Inbox *ERC20InboxTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_ERC20Inbox *ERC20InboxSession) Unpause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Unpause(&_ERC20Inbox.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) Unpause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Unpause(&_ERC20Inbox.TransactOpts)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) UnsafeCreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "unsafeCreateRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.UnsafeCreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.UnsafeCreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// ERC20InboxAllowListAddressSetIterator is returned from FilterAllowListAddressSet and is used to iterate over the raw logs and unpacked data for AllowListAddressSet events raised by the ERC20Inbox contract.
type ERC20InboxAllowListAddressSetIterator struct {
	Event *ERC20InboxAllowListAddressSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxAllowListAddressSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxAllowListAddressSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxAllowListAddressSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxAllowListAddressSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxAllowListAddressSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxAllowListAddressSet represents a AllowListAddressSet event raised by the ERC20Inbox contract.
type ERC20InboxAllowListAddressSet struct {
	User common.Address
	Val  bool
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAllowListAddressSet is a free log retrieval operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_ERC20Inbox *ERC20InboxFilterer) FilterAllowListAddressSet(opts *bind.FilterOpts, user []common.Address) (*ERC20InboxAllowListAddressSetIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxAllowListAddressSetIterator{contract: _ERC20Inbox.contract, event: "AllowListAddressSet", logs: logs, sub: sub}, nil
}

// WatchAllowListAddressSet is a free log subscription operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_ERC20Inbox *ERC20InboxFilterer) WatchAllowListAddressSet(opts *bind.WatchOpts, sink chan<- *ERC20InboxAllowListAddressSet, user []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxAllowListAddressSet)
				if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListAddressSet is a log parse operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_ERC20Inbox *ERC20InboxFilterer) ParseAllowListAddressSet(log types.Log) (*ERC20InboxAllowListAddressSet, error) {
	event := new(ERC20InboxAllowListAddressSet)
	if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxAllowListEnabledUpdatedIterator is returned from FilterAllowListEnabledUpdated and is used to iterate over the raw logs and unpacked data for AllowListEnabledUpdated events raised by the ERC20Inbox contract.
type ERC20InboxAllowListEnabledUpdatedIterator struct {
	Event *ERC20InboxAllowListEnabledUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxAllowListEnabledUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxAllowListEnabledUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxAllowListEnabledUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxAllowListEnabledUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxAllowListEnabledUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxAllowListEnabledUpdated represents a AllowListEnabledUpdated event raised by the ERC20Inbox contract.
type ERC20InboxAllowListEnabledUpdated struct {
	IsEnabled bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAllowListEnabledUpdated is a free log retrieval operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_ERC20Inbox *ERC20InboxFilterer) FilterAllowListEnabledUpdated(opts *bind.FilterOpts) (*ERC20InboxAllowListEnabledUpdatedIterator, error) {

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return &ERC20InboxAllowListEnabledUpdatedIterator{contract: _ERC20Inbox.contract, event: "AllowListEnabledUpdated", logs: logs, sub: sub}, nil
}

// WatchAllowListEnabledUpdated is a free log subscription operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_ERC20Inbox *ERC20InboxFilterer) WatchAllowListEnabledUpdated(opts *bind.WatchOpts, sink chan<- *ERC20InboxAllowListEnabledUpdated) (event.Subscription, error) {

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxAllowListEnabledUpdated)
				if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListEnabledUpdated is a log parse operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_ERC20Inbox *ERC20InboxFilterer) ParseAllowListEnabledUpdated(log types.Log) (*ERC20InboxAllowListEnabledUpdated, error) {
	event := new(ERC20InboxAllowListEnabledUpdated)
	if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDeliveredIterator struct {
	Event *ERC20InboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ERC20Inbox *ERC20InboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*ERC20InboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxInboxMessageDeliveredIterator{contract: _ERC20Inbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ERC20Inbox *ERC20InboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *ERC20InboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxInboxMessageDelivered)
				if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ERC20Inbox *ERC20InboxFilterer) ParseInboxMessageDelivered(log types.Log) (*ERC20InboxInboxMessageDelivered, error) {
	event := new(ERC20InboxInboxMessageDelivered)
	if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDeliveredFromOriginIterator struct {
	Event *ERC20InboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ERC20Inbox *ERC20InboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*ERC20InboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxInboxMessageDeliveredFromOriginIterator{contract: _ERC20Inbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ERC20Inbox *ERC20InboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *ERC20InboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxInboxMessageDeliveredFromOrigin)
				if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ERC20Inbox *ERC20InboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*ERC20InboxInboxMessageDeliveredFromOrigin, error) {
	event := new(ERC20InboxInboxMessageDeliveredFromOrigin)
	if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the ERC20Inbox contract.
type ERC20InboxPausedIterator struct {
	Event *ERC20InboxPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxPaused represents a Paused event raised by the ERC20Inbox contract.
type ERC20InboxPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) FilterPaused(opts *bind.FilterOpts) (*ERC20InboxPausedIterator, error) {

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &ERC20InboxPausedIterator{contract: _ERC20Inbox.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *ERC20InboxPaused) (event.Subscription, error) {

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxPaused)
				if err := _ERC20Inbox.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) ParsePaused(log types.Log) (*ERC20InboxPaused, error) {
	event := new(ERC20InboxPaused)
	if err := _ERC20Inbox.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the ERC20Inbox contract.
type ERC20InboxUnpausedIterator struct {
	Event *ERC20InboxUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxUnpaused represents a Unpaused event raised by the ERC20Inbox contract.
type ERC20InboxUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) FilterUnpaused(opts *bind.FilterOpts) (*ERC20InboxUnpausedIterator, error) {

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &ERC20InboxUnpausedIterator{contract: _ERC20Inbox.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *ERC20InboxUnpaused) (event.Subscription, error) {

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxUnpaused)
				if err := _ERC20Inbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) ParseUnpaused(log types.Log) (*ERC20InboxUnpaused, error) {
	event := new(ERC20InboxUnpaused)
	if err := _ERC20Inbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

func CreateERC20InboxDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint

	var maxDataSize *big.Int
	var maxDataSizeRaw string

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
			}

			if maxDataSizeRaw == "" {
				return fmt.Errorf("--max-data-size argument not specified")
			}
			maxDataSize = new(big.Int)
			maxDataSize.SetString(maxDataSizeRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			address, deploymentTransaction, _, deploymentErr := DeployERC20Inbox(
				transactionOpts,
				client,
				maxDataSize,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")

	cmd.Flags().StringVar(&maxDataSizeRaw, "max-data-size", "", "max-data-size argument")

	return cmd
}

func CreateIsAllowedCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 common.Address
	var arg0Raw string

	var capture0 bool

	cmd := &cobra.Command{
		Use:   "is-allowed",
		Short: "Call the IsAllowed view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			} else if !common.IsHexAddress(arg0Raw) {
				return fmt.Errorf("--arg-0 argument is not a valid Ethereum address")
			}
			arg0 = common.HexToAddress(arg0Raw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.IsAllowed(
				arg0,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %t\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument")

	return cmd
}
func CreateMaxDataSizeCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "max-data-size",
		Short: "Call the MaxDataSize view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.MaxDataSize()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreatePausedCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 bool

	cmd := &cobra.Command{
		Use:   "paused",
		Short: "Call the Paused view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Paused()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %t\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateSequencerInboxCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "sequencer-inbox",
		Short: "Call the SequencerInbox view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.SequencerInbox()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateAllowListEnabledCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 bool

	cmd := &cobra.Command{
		Use:   "allow-list-enabled",
		Short: "Call the AllowListEnabled view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.AllowListEnabled()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %t\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateBridgeCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "bridge",
		Short: "Call the Bridge view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Bridge()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateCalculateRetryableSubmissionFeeCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 *big.Int
	var arg0Raw string
	var arg1 *big.Int
	var arg1Raw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "calculate-retryable-submission-fee",
		Short: "Call the CalculateRetryableSubmissionFee view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			}
			arg0 = new(big.Int)
			arg0.SetString(arg0Raw, 0)

			if arg1Raw == "" {
				return fmt.Errorf("--arg-1 argument not specified")
			}
			arg1 = new(big.Int)
			arg1.SetString(arg1Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.CalculateRetryableSubmissionFee(
				arg0,
				arg1,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument")
	cmd.Flags().StringVar(&arg1Raw, "arg-1", "", "arg-1 argument")

	return cmd
}
func CreateGetProxyAdminCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "get-proxy-admin",
		Short: "Call the GetProxyAdmin view method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := ERC20InboxCallerSession{
				Contract: &contract.ERC20InboxCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetProxyAdmin()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}

func CreateSendL2MessageCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var messageData []byte
	var messageDataRaw string

	cmd := &cobra.Command{
		Use:   "send-l-2-message",
		Short: "Execute the SendL2Message method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var hexDecodemessageDataErr error

			messageData, hexDecodemessageDataErr = hex.DecodeString(messageDataRaw)
			if hexDecodemessageDataErr != nil {
				return hexDecodemessageDataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SendL2Message(
				messageData,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&messageDataRaw, "message-data", "", "message-data argument")

	return cmd
}
func CreateSendL2MessageFromOriginCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var messageData []byte
	var messageDataRaw string

	cmd := &cobra.Command{
		Use:   "send-l-2-message-from-origin",
		Short: "Execute the SendL2MessageFromOrigin method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var hexDecodemessageDataErr error

			messageData, hexDecodemessageDataErr = hex.DecodeString(messageDataRaw)
			if hexDecodemessageDataErr != nil {
				return hexDecodemessageDataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SendL2MessageFromOrigin(
				messageData,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&messageDataRaw, "message-data", "", "message-data argument")

	return cmd
}
func CreateSetAllowListCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var user []common.Address
	var userRaw string
	var val []bool
	var valRaw string

	cmd := &cobra.Command{
		Use:   "set-allow-list",
		Short: "Execute the SetAllowList method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if userRaw == "" {
				return fmt.Errorf("--user argument not specified")
			} else if strings.HasPrefix(userRaw, "@") {
				filename := strings.TrimPrefix(userRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &user)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(userRaw), &user)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			if valRaw == "" {
				return fmt.Errorf("--val argument not specified")
			} else if strings.HasPrefix(valRaw, "@") {
				filename := strings.TrimPrefix(valRaw, "@")
				contents, readErr := os.ReadFile(filename)
				if readErr != nil {
					return readErr
				}
				unmarshalErr := json.Unmarshal(contents, &val)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			} else {
				unmarshalErr := json.Unmarshal([]byte(valRaw), &val)
				if unmarshalErr != nil {
					return unmarshalErr
				}
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SetAllowList(
				user,
				val,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&userRaw, "user", "", "user argument")
	cmd.Flags().StringVar(&valRaw, "val", "", "val argument")

	return cmd
}
func CreateCreateRetryableTicketCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var to0 common.Address
	var to0Raw string
	var l2CallValue *big.Int
	var l2CallValueRaw string
	var maxSubmissionCost *big.Int
	var maxSubmissionCostRaw string
	var excessFeeRefundAddress common.Address
	var excessFeeRefundAddressRaw string
	var callValueRefundAddress common.Address
	var callValueRefundAddressRaw string
	var gasLimit0 *big.Int
	var gasLimit0Raw string
	var maxFeePerGas0 *big.Int
	var maxFeePerGas0Raw string
	var tokenTotalFeeAmount *big.Int
	var tokenTotalFeeAmountRaw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "create-retryable-ticket",
		Short: "Execute the CreateRetryableTicket method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if l2CallValueRaw == "" {
				return fmt.Errorf("--l-2-call-value argument not specified")
			}
			l2CallValue = new(big.Int)
			l2CallValue.SetString(l2CallValueRaw, 0)

			if maxSubmissionCostRaw == "" {
				return fmt.Errorf("--max-submission-cost argument not specified")
			}
			maxSubmissionCost = new(big.Int)
			maxSubmissionCost.SetString(maxSubmissionCostRaw, 0)

			if excessFeeRefundAddressRaw == "" {
				return fmt.Errorf("--excess-fee-refund-address argument not specified")
			} else if !common.IsHexAddress(excessFeeRefundAddressRaw) {
				return fmt.Errorf("--excess-fee-refund-address argument is not a valid Ethereum address")
			}
			excessFeeRefundAddress = common.HexToAddress(excessFeeRefundAddressRaw)

			if callValueRefundAddressRaw == "" {
				return fmt.Errorf("--call-value-refund-address argument not specified")
			} else if !common.IsHexAddress(callValueRefundAddressRaw) {
				return fmt.Errorf("--call-value-refund-address argument is not a valid Ethereum address")
			}
			callValueRefundAddress = common.HexToAddress(callValueRefundAddressRaw)

			if gasLimit0Raw == "" {
				return fmt.Errorf("--gas-limit-0 argument not specified")
			}
			gasLimit0 = new(big.Int)
			gasLimit0.SetString(gasLimit0Raw, 0)

			if maxFeePerGas0Raw == "" {
				return fmt.Errorf("--max-fee-per-gas-0 argument not specified")
			}
			maxFeePerGas0 = new(big.Int)
			maxFeePerGas0.SetString(maxFeePerGas0Raw, 0)

			if tokenTotalFeeAmountRaw == "" {
				return fmt.Errorf("--token-total-fee-amount argument not specified")
			}
			tokenTotalFeeAmount = new(big.Int)
			tokenTotalFeeAmount.SetString(tokenTotalFeeAmountRaw, 0)

			var hexDecodedataErr error

			data, hexDecodedataErr = hex.DecodeString(dataRaw)
			if hexDecodedataErr != nil {
				return hexDecodedataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.CreateRetryableTicket(
				to0,
				l2CallValue,
				maxSubmissionCost,
				excessFeeRefundAddress,
				callValueRefundAddress,
				gasLimit0,
				maxFeePerGas0,
				tokenTotalFeeAmount,
				data,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument")
	cmd.Flags().StringVar(&l2CallValueRaw, "l-2-call-value", "", "l-2-call-value argument")
	cmd.Flags().StringVar(&maxSubmissionCostRaw, "max-submission-cost", "", "max-submission-cost argument")
	cmd.Flags().StringVar(&excessFeeRefundAddressRaw, "excess-fee-refund-address", "", "excess-fee-refund-address argument")
	cmd.Flags().StringVar(&callValueRefundAddressRaw, "call-value-refund-address", "", "call-value-refund-address argument")
	cmd.Flags().StringVar(&gasLimit0Raw, "gas-limit-0", "", "gas-limit-0 argument")
	cmd.Flags().StringVar(&maxFeePerGas0Raw, "max-fee-per-gas-0", "", "max-fee-per-gas-0 argument")
	cmd.Flags().StringVar(&tokenTotalFeeAmountRaw, "token-total-fee-amount", "", "token-total-fee-amount argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument")

	return cmd
}
func CreateDepositErc20Command() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var amount *big.Int
	var amountRaw string

	cmd := &cobra.Command{
		Use:   "deposit-erc-20",
		Short: "Execute the DepositERC20 method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if amountRaw == "" {
				return fmt.Errorf("--amount argument not specified")
			}
			amount = new(big.Int)
			amount.SetString(amountRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.DepositERC20(
				amount,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&amountRaw, "amount", "", "amount argument")

	return cmd
}
func CreateInitializeCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var bridge common.Address
	var bridgeRaw string
	var sequencerInbox common.Address
	var sequencerInboxRaw string

	cmd := &cobra.Command{
		Use:   "initialize",
		Short: "Execute the Initialize method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if bridgeRaw == "" {
				return fmt.Errorf("--bridge argument not specified")
			} else if !common.IsHexAddress(bridgeRaw) {
				return fmt.Errorf("--bridge argument is not a valid Ethereum address")
			}
			bridge = common.HexToAddress(bridgeRaw)

			if sequencerInboxRaw == "" {
				return fmt.Errorf("--sequencer-inbox argument not specified")
			} else if !common.IsHexAddress(sequencerInboxRaw) {
				return fmt.Errorf("--sequencer-inbox argument is not a valid Ethereum address")
			}
			sequencerInbox = common.HexToAddress(sequencerInboxRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.Initialize(
				bridge,
				sequencerInbox,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&bridgeRaw, "bridge", "", "bridge argument")
	cmd.Flags().StringVar(&sequencerInboxRaw, "sequencer-inbox", "", "sequencer-inbox argument")

	return cmd
}
func CreatePauseCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	cmd := &cobra.Command{
		Use:   "pause",
		Short: "Execute the Pause method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.Pause()
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	return cmd
}
func CreateSendContractTransactionCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var gasLimit0 *big.Int
	var gasLimit0Raw string
	var maxFeePerGas0 *big.Int
	var maxFeePerGas0Raw string
	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "send-contract-transaction",
		Short: "Execute the SendContractTransaction method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if gasLimit0Raw == "" {
				return fmt.Errorf("--gas-limit-0 argument not specified")
			}
			gasLimit0 = new(big.Int)
			gasLimit0.SetString(gasLimit0Raw, 0)

			if maxFeePerGas0Raw == "" {
				return fmt.Errorf("--max-fee-per-gas-0 argument not specified")
			}
			maxFeePerGas0 = new(big.Int)
			maxFeePerGas0.SetString(maxFeePerGas0Raw, 0)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			var hexDecodedataErr error

			data, hexDecodedataErr = hex.DecodeString(dataRaw)
			if hexDecodedataErr != nil {
				return hexDecodedataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SendContractTransaction(
				gasLimit0,
				maxFeePerGas0,
				to0,
				value0,
				data,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&gasLimit0Raw, "gas-limit-0", "", "gas-limit-0 argument")
	cmd.Flags().StringVar(&maxFeePerGas0Raw, "max-fee-per-gas-0", "", "max-fee-per-gas-0 argument")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument")

	return cmd
}
func CreateUnpauseCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	cmd := &cobra.Command{
		Use:   "unpause",
		Short: "Execute the Unpause method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.Unpause()
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	return cmd
}
func CreateSendUnsignedTransactionCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var gasLimit0 *big.Int
	var gasLimit0Raw string
	var maxFeePerGas0 *big.Int
	var maxFeePerGas0Raw string
	var nonce0 *big.Int
	var nonce0Raw string
	var to0 common.Address
	var to0Raw string
	var value0 *big.Int
	var value0Raw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "send-unsigned-transaction",
		Short: "Execute the SendUnsignedTransaction method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if gasLimit0Raw == "" {
				return fmt.Errorf("--gas-limit-0 argument not specified")
			}
			gasLimit0 = new(big.Int)
			gasLimit0.SetString(gasLimit0Raw, 0)

			if maxFeePerGas0Raw == "" {
				return fmt.Errorf("--max-fee-per-gas-0 argument not specified")
			}
			maxFeePerGas0 = new(big.Int)
			maxFeePerGas0.SetString(maxFeePerGas0Raw, 0)

			if nonce0Raw == "" {
				return fmt.Errorf("--nonce-0 argument not specified")
			}
			nonce0 = new(big.Int)
			nonce0.SetString(nonce0Raw, 0)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if value0Raw == "" {
				return fmt.Errorf("--value-0 argument not specified")
			}
			value0 = new(big.Int)
			value0.SetString(value0Raw, 0)

			var hexDecodedataErr error

			data, hexDecodedataErr = hex.DecodeString(dataRaw)
			if hexDecodedataErr != nil {
				return hexDecodedataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SendUnsignedTransaction(
				gasLimit0,
				maxFeePerGas0,
				nonce0,
				to0,
				value0,
				data,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&gasLimit0Raw, "gas-limit-0", "", "gas-limit-0 argument")
	cmd.Flags().StringVar(&maxFeePerGas0Raw, "max-fee-per-gas-0", "", "max-fee-per-gas-0 argument")
	cmd.Flags().StringVar(&nonce0Raw, "nonce-0", "", "nonce-0 argument")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument")
	cmd.Flags().StringVar(&value0Raw, "value-0", "", "value-0 argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument")

	return cmd
}
func CreateSetAllowListEnabledCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var allowListEnabled bool
	var allowListEnabledRaw string

	cmd := &cobra.Command{
		Use:   "set-allow-list-enabled",
		Short: "Execute the SetAllowListEnabled method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			allowListEnabledRawLower := strings.ToLower(allowListEnabledRaw)
			switch allowListEnabledRawLower {
			case "true", "t", "y", "yes", "1":
				allowListEnabled = true
			case "false", "f", "n", "no", "0":
				allowListEnabled = false
			default:
				return fmt.Errorf("--allow-list-enabled argument is not valid (value: %s)", allowListEnabledRaw)
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.SetAllowListEnabled(
				allowListEnabled,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&allowListEnabledRaw, "allow-list-enabled", "", "allow-list-enabled argument (true, t, y, yes, 1 OR false, f, n, no, 0)")

	return cmd
}
func CreateUnsafeCreateRetryableTicketCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var to0 common.Address
	var to0Raw string
	var l2CallValue *big.Int
	var l2CallValueRaw string
	var maxSubmissionCost *big.Int
	var maxSubmissionCostRaw string
	var excessFeeRefundAddress common.Address
	var excessFeeRefundAddressRaw string
	var callValueRefundAddress common.Address
	var callValueRefundAddressRaw string
	var gasLimit0 *big.Int
	var gasLimit0Raw string
	var maxFeePerGas0 *big.Int
	var maxFeePerGas0Raw string
	var tokenTotalFeeAmount *big.Int
	var tokenTotalFeeAmountRaw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "unsafe-create-retryable-ticket",
		Short: "Execute the UnsafeCreateRetryableTicket method on a ERC20Inbox contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if l2CallValueRaw == "" {
				return fmt.Errorf("--l-2-call-value argument not specified")
			}
			l2CallValue = new(big.Int)
			l2CallValue.SetString(l2CallValueRaw, 0)

			if maxSubmissionCostRaw == "" {
				return fmt.Errorf("--max-submission-cost argument not specified")
			}
			maxSubmissionCost = new(big.Int)
			maxSubmissionCost.SetString(maxSubmissionCostRaw, 0)

			if excessFeeRefundAddressRaw == "" {
				return fmt.Errorf("--excess-fee-refund-address argument not specified")
			} else if !common.IsHexAddress(excessFeeRefundAddressRaw) {
				return fmt.Errorf("--excess-fee-refund-address argument is not a valid Ethereum address")
			}
			excessFeeRefundAddress = common.HexToAddress(excessFeeRefundAddressRaw)

			if callValueRefundAddressRaw == "" {
				return fmt.Errorf("--call-value-refund-address argument not specified")
			} else if !common.IsHexAddress(callValueRefundAddressRaw) {
				return fmt.Errorf("--call-value-refund-address argument is not a valid Ethereum address")
			}
			callValueRefundAddress = common.HexToAddress(callValueRefundAddressRaw)

			if gasLimit0Raw == "" {
				return fmt.Errorf("--gas-limit-0 argument not specified")
			}
			gasLimit0 = new(big.Int)
			gasLimit0.SetString(gasLimit0Raw, 0)

			if maxFeePerGas0Raw == "" {
				return fmt.Errorf("--max-fee-per-gas-0 argument not specified")
			}
			maxFeePerGas0 = new(big.Int)
			maxFeePerGas0.SetString(maxFeePerGas0Raw, 0)

			if tokenTotalFeeAmountRaw == "" {
				return fmt.Errorf("--token-total-fee-amount argument not specified")
			}
			tokenTotalFeeAmount = new(big.Int)
			tokenTotalFeeAmount.SetString(tokenTotalFeeAmountRaw, 0)

			var hexDecodedataErr error

			data, hexDecodedataErr = hex.DecodeString(dataRaw)
			if hexDecodedataErr != nil {
				return hexDecodedataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewERC20Inbox(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := ERC20InboxTransactorSession{
				Contract:     &contract.ERC20InboxTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.UnsafeCreateRetryableTicket(
				to0,
				l2CallValue,
				maxSubmissionCost,
				excessFeeRefundAddress,
				callValueRefundAddress,
				gasLimit0,
				maxFeePerGas0,
				tokenTotalFeeAmount,
				data,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument")
	cmd.Flags().StringVar(&l2CallValueRaw, "l-2-call-value", "", "l-2-call-value argument")
	cmd.Flags().StringVar(&maxSubmissionCostRaw, "max-submission-cost", "", "max-submission-cost argument")
	cmd.Flags().StringVar(&excessFeeRefundAddressRaw, "excess-fee-refund-address", "", "excess-fee-refund-address argument")
	cmd.Flags().StringVar(&callValueRefundAddressRaw, "call-value-refund-address", "", "call-value-refund-address argument")
	cmd.Flags().StringVar(&gasLimit0Raw, "gas-limit-0", "", "gas-limit-0 argument")
	cmd.Flags().StringVar(&maxFeePerGas0Raw, "max-fee-per-gas-0", "", "max-fee-per-gas-0 argument")
	cmd.Flags().StringVar(&tokenTotalFeeAmountRaw, "token-total-fee-amount", "", "token-total-fee-amount argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the ERC_20_INBOX_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the ERC_20_INBOX_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("ERC_20_INBOX_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreateERC20InboxCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "erc-20-inbox",
		Short: "Interact with the ERC20Inbox contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployERC20Inbox := CreateERC20InboxDeploymentCommand()
	cmdDeployERC20Inbox.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployERC20Inbox)

	cmdViewIsAllowed := CreateIsAllowedCommand()
	cmdViewIsAllowed.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewIsAllowed)
	cmdViewMaxDataSize := CreateMaxDataSizeCommand()
	cmdViewMaxDataSize.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewMaxDataSize)
	cmdViewPaused := CreatePausedCommand()
	cmdViewPaused.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewPaused)
	cmdViewSequencerInbox := CreateSequencerInboxCommand()
	cmdViewSequencerInbox.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewSequencerInbox)
	cmdViewAllowListEnabled := CreateAllowListEnabledCommand()
	cmdViewAllowListEnabled.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewAllowListEnabled)
	cmdViewBridge := CreateBridgeCommand()
	cmdViewBridge.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewBridge)
	cmdViewCalculateRetryableSubmissionFee := CreateCalculateRetryableSubmissionFeeCommand()
	cmdViewCalculateRetryableSubmissionFee.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCalculateRetryableSubmissionFee)
	cmdViewGetProxyAdmin := CreateGetProxyAdminCommand()
	cmdViewGetProxyAdmin.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetProxyAdmin)

	cmdTransactSendL2Message := CreateSendL2MessageCommand()
	cmdTransactSendL2Message.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSendL2Message)
	cmdTransactSendL2MessageFromOrigin := CreateSendL2MessageFromOriginCommand()
	cmdTransactSendL2MessageFromOrigin.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSendL2MessageFromOrigin)
	cmdTransactSetAllowList := CreateSetAllowListCommand()
	cmdTransactSetAllowList.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetAllowList)
	cmdTransactCreateRetryableTicket := CreateCreateRetryableTicketCommand()
	cmdTransactCreateRetryableTicket.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactCreateRetryableTicket)
	cmdTransactDepositERC20 := CreateDepositErc20Command()
	cmdTransactDepositERC20.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactDepositERC20)
	cmdTransactInitialize := CreateInitializeCommand()
	cmdTransactInitialize.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactInitialize)
	cmdTransactPause := CreatePauseCommand()
	cmdTransactPause.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactPause)
	cmdTransactSendContractTransaction := CreateSendContractTransactionCommand()
	cmdTransactSendContractTransaction.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSendContractTransaction)
	cmdTransactUnpause := CreateUnpauseCommand()
	cmdTransactUnpause.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactUnpause)
	cmdTransactSendUnsignedTransaction := CreateSendUnsignedTransactionCommand()
	cmdTransactSendUnsignedTransaction.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSendUnsignedTransaction)
	cmdTransactSetAllowListEnabled := CreateSetAllowListEnabledCommand()
	cmdTransactSetAllowListEnabled.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetAllowListEnabled)
	cmdTransactUnsafeCreateRetryableTicket := CreateUnsafeCreateRetryableTicketCommand()
	cmdTransactUnsafeCreateRetryableTicket.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactUnsafeCreateRetryableTicket)

	return cmd
}

