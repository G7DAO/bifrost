// This file was generated by seer: https://github.com/G7DAO/seer.
// seer version: 0.1.3
// seer command: seer evm generate --package NodeInterface --cli --struct NodeInterface
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package NodeInterface

import (
	"errors"
	"math/big"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"fmt"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// NodeInterfaceMetaData contains all meta data concerning the NodeInterface contract.
var NodeInterfaceMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"l2BlockNum\",\"type\":\"uint64\"}],\"name\":\"blockL1Num\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"l1BlockNum\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"size\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"leaf\",\"type\":\"uint64\"}],\"name\":\"constructOutboxProof\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"send\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"estimateRetryableTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNum\",\"type\":\"uint64\"}],\"name\":\"findBatchContainingBlock\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"batch\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"contractCreation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"gasEstimateComponents\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"gasEstimate\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"gasEstimateForL1\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1BaseFeeEstimate\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"contractCreation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"gasEstimateL1Component\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"gasEstimateForL1\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1BaseFeeEstimate\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"getL1Confirmations\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNum\",\"type\":\"uint64\"}],\"name\":\"l2BlockRangeForL1\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"firstBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastBlock\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchNum\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"}],\"name\":\"legacyLookupMessageBatchProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1Dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"calldataForL1\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nitroGenesisBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
}

// NodeInterfaceABI is the input ABI used to generate the binding from.
// Deprecated: Use NodeInterfaceMetaData.ABI instead.
var NodeInterfaceABI = NodeInterfaceMetaData.ABI

// NodeInterface is an auto generated Go binding around an Ethereum contract.
type NodeInterface struct {
	NodeInterfaceCaller     // Read-only binding to the contract
	NodeInterfaceTransactor // Write-only binding to the contract
	NodeInterfaceFilterer   // Log filterer for contract events
}

// NodeInterfaceCaller is an auto generated read-only Go binding around an Ethereum contract.
type NodeInterfaceCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeInterfaceTransactor is an auto generated write-only Go binding around an Ethereum contract.
type NodeInterfaceTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeInterfaceFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type NodeInterfaceFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeInterfaceSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type NodeInterfaceSession struct {
	Contract     *NodeInterface    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NodeInterfaceCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type NodeInterfaceCallerSession struct {
	Contract *NodeInterfaceCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// NodeInterfaceTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type NodeInterfaceTransactorSession struct {
	Contract     *NodeInterfaceTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// NodeInterfaceRaw is an auto generated low-level Go binding around an Ethereum contract.
type NodeInterfaceRaw struct {
	Contract *NodeInterface // Generic contract binding to access the raw methods on
}

// NodeInterfaceCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type NodeInterfaceCallerRaw struct {
	Contract *NodeInterfaceCaller // Generic read-only contract binding to access the raw methods on
}

// NodeInterfaceTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type NodeInterfaceTransactorRaw struct {
	Contract *NodeInterfaceTransactor // Generic write-only contract binding to access the raw methods on
}

// NewNodeInterface creates a new instance of NodeInterface, bound to a specific deployed contract.
func NewNodeInterface(address common.Address, backend bind.ContractBackend) (*NodeInterface, error) {
	contract, err := bindNodeInterface(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &NodeInterface{NodeInterfaceCaller: NodeInterfaceCaller{contract: contract}, NodeInterfaceTransactor: NodeInterfaceTransactor{contract: contract}, NodeInterfaceFilterer: NodeInterfaceFilterer{contract: contract}}, nil
}

// NewNodeInterfaceCaller creates a new read-only instance of NodeInterface, bound to a specific deployed contract.
func NewNodeInterfaceCaller(address common.Address, caller bind.ContractCaller) (*NodeInterfaceCaller, error) {
	contract, err := bindNodeInterface(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &NodeInterfaceCaller{contract: contract}, nil
}

// NewNodeInterfaceTransactor creates a new write-only instance of NodeInterface, bound to a specific deployed contract.
func NewNodeInterfaceTransactor(address common.Address, transactor bind.ContractTransactor) (*NodeInterfaceTransactor, error) {
	contract, err := bindNodeInterface(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &NodeInterfaceTransactor{contract: contract}, nil
}

// NewNodeInterfaceFilterer creates a new log filterer instance of NodeInterface, bound to a specific deployed contract.
func NewNodeInterfaceFilterer(address common.Address, filterer bind.ContractFilterer) (*NodeInterfaceFilterer, error) {
	contract, err := bindNodeInterface(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &NodeInterfaceFilterer{contract: contract}, nil
}

// bindNodeInterface binds a generic wrapper to an already deployed contract.
func bindNodeInterface(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := NodeInterfaceMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeInterface *NodeInterfaceRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _NodeInterface.Contract.NodeInterfaceCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeInterface *NodeInterfaceRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeInterface.Contract.NodeInterfaceTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeInterface *NodeInterfaceRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeInterface.Contract.NodeInterfaceTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeInterface *NodeInterfaceCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _NodeInterface.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeInterface *NodeInterfaceTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeInterface.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeInterface *NodeInterfaceTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeInterface.Contract.contract.Transact(opts, method, params...)
}

// BlockL1Num is a free data retrieval call binding the contract method 0x6f275ef2.
//
// Solidity: function blockL1Num(uint64 l2BlockNum) view returns(uint64 l1BlockNum)
func (_NodeInterface *NodeInterfaceCaller) BlockL1Num(opts *bind.CallOpts, l2BlockNum uint64) (uint64, error) {
	var out []interface{}
	err := _NodeInterface.contract.Call(opts, &out, "blockL1Num", l2BlockNum)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// BlockL1Num is a free data retrieval call binding the contract method 0x6f275ef2.
//
// Solidity: function blockL1Num(uint64 l2BlockNum) view returns(uint64 l1BlockNum)
func (_NodeInterface *NodeInterfaceSession) BlockL1Num(l2BlockNum uint64) (uint64, error) {
	return _NodeInterface.Contract.BlockL1Num(&_NodeInterface.CallOpts, l2BlockNum)
}

// BlockL1Num is a free data retrieval call binding the contract method 0x6f275ef2.
//
// Solidity: function blockL1Num(uint64 l2BlockNum) view returns(uint64 l1BlockNum)
func (_NodeInterface *NodeInterfaceCallerSession) BlockL1Num(l2BlockNum uint64) (uint64, error) {
	return _NodeInterface.Contract.BlockL1Num(&_NodeInterface.CallOpts, l2BlockNum)
}

// ConstructOutboxProof is a free data retrieval call binding the contract method 0x42696350.
//
// Solidity: function constructOutboxProof(uint64 size, uint64 leaf) view returns(bytes32 send, bytes32 root, bytes32[] proof)
func (_NodeInterface *NodeInterfaceCaller) ConstructOutboxProof(opts *bind.CallOpts, size uint64, leaf uint64) (struct {
	Send  [32]byte
	Root  [32]byte
	Proof [][32]byte
}, error) {
	var out []interface{}
	err := _NodeInterface.contract.Call(opts, &out, "constructOutboxProof", size, leaf)

	outstruct := new(struct {
		Send  [32]byte
		Root  [32]byte
		Proof [][32]byte
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Send = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.Root = *abi.ConvertType(out[1], new([32]byte)).(*[32]byte)
	outstruct.Proof = *abi.ConvertType(out[2], new([][32]byte)).(*[][32]byte)

	return *outstruct, err

}

// ConstructOutboxProof is a free data retrieval call binding the contract method 0x42696350.
//
// Solidity: function constructOutboxProof(uint64 size, uint64 leaf) view returns(bytes32 send, bytes32 root, bytes32[] proof)
func (_NodeInterface *NodeInterfaceSession) ConstructOutboxProof(size uint64, leaf uint64) (struct {
	Send  [32]byte
	Root  [32]byte
	Proof [][32]byte
}, error) {
	return _NodeInterface.Contract.ConstructOutboxProof(&_NodeInterface.CallOpts, size, leaf)
}

// ConstructOutboxProof is a free data retrieval call binding the contract method 0x42696350.
//
// Solidity: function constructOutboxProof(uint64 size, uint64 leaf) view returns(bytes32 send, bytes32 root, bytes32[] proof)
func (_NodeInterface *NodeInterfaceCallerSession) ConstructOutboxProof(size uint64, leaf uint64) (struct {
	Send  [32]byte
	Root  [32]byte
	Proof [][32]byte
}, error) {
	return _NodeInterface.Contract.ConstructOutboxProof(&_NodeInterface.CallOpts, size, leaf)
}

// FindBatchContainingBlock is a free data retrieval call binding the contract method 0x81f1adaf.
//
// Solidity: function findBatchContainingBlock(uint64 blockNum) view returns(uint64 batch)
func (_NodeInterface *NodeInterfaceCaller) FindBatchContainingBlock(opts *bind.CallOpts, blockNum uint64) (uint64, error) {
	var out []interface{}
	err := _NodeInterface.contract.Call(opts, &out, "findBatchContainingBlock", blockNum)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// FindBatchContainingBlock is a free data retrieval call binding the contract method 0x81f1adaf.
//
// Solidity: function findBatchContainingBlock(uint64 blockNum) view returns(uint64 batch)
func (_NodeInterface *NodeInterfaceSession) FindBatchContainingBlock(blockNum uint64) (uint64, error) {
	return _NodeInterface.Contract.FindBatchContainingBlock(&_NodeInterface.CallOpts, blockNum)
}

// FindBatchContainingBlock is a free data retrieval call binding the contract method 0x81f1adaf.
//
// Solidity: function findBatchContainingBlock(uint64 blockNum) view returns(uint64 batch)
func (_NodeInterface *NodeInterfaceCallerSession) FindBatchContainingBlock(blockNum uint64) (uint64, error) {
	return _NodeInterface.Contract.FindBatchContainingBlock(&_NodeInterface.CallOpts, blockNum)
}

// GetL1Confirmations is a free data retrieval call binding the contract method 0xe5ca238c.
//
// Solidity: function getL1Confirmations(bytes32 blockHash) view returns(uint64 confirmations)
func (_NodeInterface *NodeInterfaceCaller) GetL1Confirmations(opts *bind.CallOpts, blockHash [32]byte) (uint64, error) {
	var out []interface{}
	err := _NodeInterface.contract.Call(opts, &out, "getL1Confirmations", blockHash)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// GetL1Confirmations is a free data retrieval call binding the contract method 0xe5ca238c.
//
// Solidity: function getL1Confirmations(bytes32 blockHash) view returns(uint64 confirmations)
func (_NodeInterface *NodeInterfaceSession) GetL1Confirmations(blockHash [32]byte) (uint64, error) {
	return _NodeInterface.Contract.GetL1Confirmations(&_NodeInterface.CallOpts, blockHash)
}

// GetL1Confirmations is a free data retrieval call binding the contract method 0xe5ca238c.
//
// Solidity: function getL1Confirmations(bytes32 blockHash) view returns(uint64 confirmations)
func (_NodeInterface *NodeInterfaceCallerSession) GetL1Confirmations(blockHash [32]byte) (uint64, error) {
	return _NodeInterface.Contract.GetL1Confirmations(&_NodeInterface.CallOpts, blockHash)
}

// L2BlockRangeForL1 is a free data retrieval call binding the contract method 0x48e7f811.
//
// Solidity: function l2BlockRangeForL1(uint64 blockNum) view returns(uint64 firstBlock, uint64 lastBlock)
func (_NodeInterface *NodeInterfaceCaller) L2BlockRangeForL1(opts *bind.CallOpts, blockNum uint64) (struct {
	FirstBlock uint64
	LastBlock  uint64
}, error) {
	var out []interface{}
	err := _NodeInterface.contract.Call(opts, &out, "l2BlockRangeForL1", blockNum)

	outstruct := new(struct {
		FirstBlock uint64
		LastBlock  uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.FirstBlock = *abi.ConvertType(out[0], new(uint64)).(*uint64)
	outstruct.LastBlock = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// L2BlockRangeForL1 is a free data retrieval call binding the contract method 0x48e7f811.
//
// Solidity: function l2BlockRangeForL1(uint64 blockNum) view returns(uint64 firstBlock, uint64 lastBlock)
func (_NodeInterface *NodeInterfaceSession) L2BlockRangeForL1(blockNum uint64) (struct {
	FirstBlock uint64
	LastBlock  uint64
}, error) {
	return _NodeInterface.Contract.L2BlockRangeForL1(&_NodeInterface.CallOpts, blockNum)
}

// L2BlockRangeForL1 is a free data retrieval call binding the contract method 0x48e7f811.
//
// Solidity: function l2BlockRangeForL1(uint64 blockNum) view returns(uint64 firstBlock, uint64 lastBlock)
func (_NodeInterface *NodeInterfaceCallerSession) L2BlockRangeForL1(blockNum uint64) (struct {
	FirstBlock uint64
	LastBlock  uint64
}, error) {
	return _NodeInterface.Contract.L2BlockRangeForL1(&_NodeInterface.CallOpts, blockNum)
}

// LegacyLookupMessageBatchProof is a free data retrieval call binding the contract method 0x89496270.
//
// Solidity: function legacyLookupMessageBatchProof(uint256 batchNum, uint64 index) view returns(bytes32[] proof, uint256 path, address l2Sender, address l1Dest, uint256 l2Block, uint256 l1Block, uint256 timestamp, uint256 amount, bytes calldataForL1)
func (_NodeInterface *NodeInterfaceCaller) LegacyLookupMessageBatchProof(opts *bind.CallOpts, batchNum *big.Int, index uint64) (struct {
	Proof         [][32]byte
	Path          *big.Int
	L2Sender      common.Address
	L1Dest        common.Address
	L2Block       *big.Int
	L1Block       *big.Int
	Timestamp     *big.Int
	Amount        *big.Int
	CalldataForL1 []byte
}, error) {
	var out []interface{}
	err := _NodeInterface.contract.Call(opts, &out, "legacyLookupMessageBatchProof", batchNum, index)

	outstruct := new(struct {
		Proof         [][32]byte
		Path          *big.Int
		L2Sender      common.Address
		L1Dest        common.Address
		L2Block       *big.Int
		L1Block       *big.Int
		Timestamp     *big.Int
		Amount        *big.Int
		CalldataForL1 []byte
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Proof = *abi.ConvertType(out[0], new([][32]byte)).(*[][32]byte)
	outstruct.Path = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.L2Sender = *abi.ConvertType(out[2], new(common.Address)).(*common.Address)
	outstruct.L1Dest = *abi.ConvertType(out[3], new(common.Address)).(*common.Address)
	outstruct.L2Block = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.L1Block = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[6], new(*big.Int)).(**big.Int)
	outstruct.Amount = *abi.ConvertType(out[7], new(*big.Int)).(**big.Int)
	outstruct.CalldataForL1 = *abi.ConvertType(out[8], new([]byte)).(*[]byte)

	return *outstruct, err

}

// LegacyLookupMessageBatchProof is a free data retrieval call binding the contract method 0x89496270.
//
// Solidity: function legacyLookupMessageBatchProof(uint256 batchNum, uint64 index) view returns(bytes32[] proof, uint256 path, address l2Sender, address l1Dest, uint256 l2Block, uint256 l1Block, uint256 timestamp, uint256 amount, bytes calldataForL1)
func (_NodeInterface *NodeInterfaceSession) LegacyLookupMessageBatchProof(batchNum *big.Int, index uint64) (struct {
	Proof         [][32]byte
	Path          *big.Int
	L2Sender      common.Address
	L1Dest        common.Address
	L2Block       *big.Int
	L1Block       *big.Int
	Timestamp     *big.Int
	Amount        *big.Int
	CalldataForL1 []byte
}, error) {
	return _NodeInterface.Contract.LegacyLookupMessageBatchProof(&_NodeInterface.CallOpts, batchNum, index)
}

// LegacyLookupMessageBatchProof is a free data retrieval call binding the contract method 0x89496270.
//
// Solidity: function legacyLookupMessageBatchProof(uint256 batchNum, uint64 index) view returns(bytes32[] proof, uint256 path, address l2Sender, address l1Dest, uint256 l2Block, uint256 l1Block, uint256 timestamp, uint256 amount, bytes calldataForL1)
func (_NodeInterface *NodeInterfaceCallerSession) LegacyLookupMessageBatchProof(batchNum *big.Int, index uint64) (struct {
	Proof         [][32]byte
	Path          *big.Int
	L2Sender      common.Address
	L1Dest        common.Address
	L2Block       *big.Int
	L1Block       *big.Int
	Timestamp     *big.Int
	Amount        *big.Int
	CalldataForL1 []byte
}, error) {
	return _NodeInterface.Contract.LegacyLookupMessageBatchProof(&_NodeInterface.CallOpts, batchNum, index)
}

// NitroGenesisBlock is a free data retrieval call binding the contract method 0x93a2fe21.
//
// Solidity: function nitroGenesisBlock() pure returns(uint256 number)
func (_NodeInterface *NodeInterfaceCaller) NitroGenesisBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _NodeInterface.contract.Call(opts, &out, "nitroGenesisBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NitroGenesisBlock is a free data retrieval call binding the contract method 0x93a2fe21.
//
// Solidity: function nitroGenesisBlock() pure returns(uint256 number)
func (_NodeInterface *NodeInterfaceSession) NitroGenesisBlock() (*big.Int, error) {
	return _NodeInterface.Contract.NitroGenesisBlock(&_NodeInterface.CallOpts)
}

// NitroGenesisBlock is a free data retrieval call binding the contract method 0x93a2fe21.
//
// Solidity: function nitroGenesisBlock() pure returns(uint256 number)
func (_NodeInterface *NodeInterfaceCallerSession) NitroGenesisBlock() (*big.Int, error) {
	return _NodeInterface.Contract.NitroGenesisBlock(&_NodeInterface.CallOpts)
}

// EstimateRetryableTicket is a paid mutator transaction binding the contract method 0xc3dc5879.
//
// Solidity: function estimateRetryableTicket(address sender, uint256 deposit, address to, uint256 l2CallValue, address excessFeeRefundAddress, address callValueRefundAddress, bytes data) returns()
func (_NodeInterface *NodeInterfaceTransactor) EstimateRetryableTicket(opts *bind.TransactOpts, sender common.Address, deposit *big.Int, to common.Address, l2CallValue *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, data []byte) (*types.Transaction, error) {
	return _NodeInterface.contract.Transact(opts, "estimateRetryableTicket", sender, deposit, to, l2CallValue, excessFeeRefundAddress, callValueRefundAddress, data)
}

// EstimateRetryableTicket is a paid mutator transaction binding the contract method 0xc3dc5879.
//
// Solidity: function estimateRetryableTicket(address sender, uint256 deposit, address to, uint256 l2CallValue, address excessFeeRefundAddress, address callValueRefundAddress, bytes data) returns()
func (_NodeInterface *NodeInterfaceSession) EstimateRetryableTicket(sender common.Address, deposit *big.Int, to common.Address, l2CallValue *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, data []byte) (*types.Transaction, error) {
	return _NodeInterface.Contract.EstimateRetryableTicket(&_NodeInterface.TransactOpts, sender, deposit, to, l2CallValue, excessFeeRefundAddress, callValueRefundAddress, data)
}

// EstimateRetryableTicket is a paid mutator transaction binding the contract method 0xc3dc5879.
//
// Solidity: function estimateRetryableTicket(address sender, uint256 deposit, address to, uint256 l2CallValue, address excessFeeRefundAddress, address callValueRefundAddress, bytes data) returns()
func (_NodeInterface *NodeInterfaceTransactorSession) EstimateRetryableTicket(sender common.Address, deposit *big.Int, to common.Address, l2CallValue *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, data []byte) (*types.Transaction, error) {
	return _NodeInterface.Contract.EstimateRetryableTicket(&_NodeInterface.TransactOpts, sender, deposit, to, l2CallValue, excessFeeRefundAddress, callValueRefundAddress, data)
}

// GasEstimateComponents is a paid mutator transaction binding the contract method 0xc94e6eeb.
//
// Solidity: function gasEstimateComponents(address to, bool contractCreation, bytes data) payable returns(uint64 gasEstimate, uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate)
func (_NodeInterface *NodeInterfaceTransactor) GasEstimateComponents(opts *bind.TransactOpts, to common.Address, contractCreation bool, data []byte) (*types.Transaction, error) {
	return _NodeInterface.contract.Transact(opts, "gasEstimateComponents", to, contractCreation, data)
}

// GasEstimateComponents is a paid mutator transaction binding the contract method 0xc94e6eeb.
//
// Solidity: function gasEstimateComponents(address to, bool contractCreation, bytes data) payable returns(uint64 gasEstimate, uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate)
func (_NodeInterface *NodeInterfaceSession) GasEstimateComponents(to common.Address, contractCreation bool, data []byte) (*types.Transaction, error) {
	return _NodeInterface.Contract.GasEstimateComponents(&_NodeInterface.TransactOpts, to, contractCreation, data)
}

// GasEstimateComponents is a paid mutator transaction binding the contract method 0xc94e6eeb.
//
// Solidity: function gasEstimateComponents(address to, bool contractCreation, bytes data) payable returns(uint64 gasEstimate, uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate)
func (_NodeInterface *NodeInterfaceTransactorSession) GasEstimateComponents(to common.Address, contractCreation bool, data []byte) (*types.Transaction, error) {
	return _NodeInterface.Contract.GasEstimateComponents(&_NodeInterface.TransactOpts, to, contractCreation, data)
}

// GasEstimateL1Component is a paid mutator transaction binding the contract method 0x77d488a2.
//
// Solidity: function gasEstimateL1Component(address to, bool contractCreation, bytes data) payable returns(uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate)
func (_NodeInterface *NodeInterfaceTransactor) GasEstimateL1Component(opts *bind.TransactOpts, to common.Address, contractCreation bool, data []byte) (*types.Transaction, error) {
	return _NodeInterface.contract.Transact(opts, "gasEstimateL1Component", to, contractCreation, data)
}

// GasEstimateL1Component is a paid mutator transaction binding the contract method 0x77d488a2.
//
// Solidity: function gasEstimateL1Component(address to, bool contractCreation, bytes data) payable returns(uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate)
func (_NodeInterface *NodeInterfaceSession) GasEstimateL1Component(to common.Address, contractCreation bool, data []byte) (*types.Transaction, error) {
	return _NodeInterface.Contract.GasEstimateL1Component(&_NodeInterface.TransactOpts, to, contractCreation, data)
}

// GasEstimateL1Component is a paid mutator transaction binding the contract method 0x77d488a2.
//
// Solidity: function gasEstimateL1Component(address to, bool contractCreation, bytes data) payable returns(uint64 gasEstimateForL1, uint256 baseFee, uint256 l1BaseFeeEstimate)
func (_NodeInterface *NodeInterfaceTransactorSession) GasEstimateL1Component(to common.Address, contractCreation bool, data []byte) (*types.Transaction, error) {
	return _NodeInterface.Contract.GasEstimateL1Component(&_NodeInterface.TransactOpts, to, contractCreation, data)
}

func CreateLegacyLookupMessageBatchProofCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var batchNum *big.Int
	var batchNumRaw string
	var index uint64

	var capture0 struct {
		Proof         [][32]byte
		Path          *big.Int
		L2Sender      common.Address
		L1Dest        common.Address
		L2Block       *big.Int
		L1Block       *big.Int
		Timestamp     *big.Int
		Amount        *big.Int
		CalldataForL1 []byte
	}

	cmd := &cobra.Command{
		Use:   "legacy-lookup-message-batch-proof",
		Short: "Call the LegacyLookupMessageBatchProof view method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if batchNumRaw == "" {
				return fmt.Errorf("--batch-num argument not specified")
			}
			batchNum = new(big.Int)
			batchNum.SetString(batchNumRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := NodeInterfaceCallerSession{
				Contract: &contract.NodeInterfaceCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.LegacyLookupMessageBatchProof(
				batchNum,
				index,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&batchNumRaw, "batch-num", "", "batch-num argument")
	cmd.Flags().Uint64Var(&index, "index", 0, "index argument")

	return cmd
}
func CreateNitroGenesisBlockCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "nitro-genesis-block",
		Short: "Call the NitroGenesisBlock view method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := NodeInterfaceCallerSession{
				Contract: &contract.NodeInterfaceCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.NitroGenesisBlock()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateBlockL1NumCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var l2BlockNum uint64

	var capture0 uint64

	cmd := &cobra.Command{
		Use:   "block-l-1-num",
		Short: "Call the BlockL1Num view method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := NodeInterfaceCallerSession{
				Contract: &contract.NodeInterfaceCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.BlockL1Num(
				l2BlockNum,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %d\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().Uint64Var(&l2BlockNum, "l-2-block-num", 0, "l-2-block-num argument")

	return cmd
}
func CreateConstructOutboxProofCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var size uint64

	var leaf uint64

	var capture0 struct {
		Send  [32]byte
		Root  [32]byte
		Proof [][32]byte
	}

	cmd := &cobra.Command{
		Use:   "construct-outbox-proof",
		Short: "Call the ConstructOutboxProof view method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := NodeInterfaceCallerSession{
				Contract: &contract.NodeInterfaceCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.ConstructOutboxProof(
				size,
				leaf,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().Uint64Var(&size, "size", 0, "size argument")
	cmd.Flags().Uint64Var(&leaf, "leaf", 0, "leaf argument")

	return cmd
}
func CreateFindBatchContainingBlockCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var blockNum uint64

	var capture0 uint64

	cmd := &cobra.Command{
		Use:   "find-batch-containing-block",
		Short: "Call the FindBatchContainingBlock view method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := NodeInterfaceCallerSession{
				Contract: &contract.NodeInterfaceCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.FindBatchContainingBlock(
				blockNum,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %d\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().Uint64Var(&blockNum, "block-num", 0, "block-num argument")

	return cmd
}
func CreateGetL1ConfirmationsCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var blockHash [32]byte
	var blockHashRaw string

	var capture0 uint64

	cmd := &cobra.Command{
		Use:   "get-l-1-confirmations",
		Short: "Call the GetL1Confirmations view method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var hexDecodeblockHashErr error

			var intermediateblockHashLeaf []byte
			intermediateblockHashLeaf, hexDecodeblockHashErr = hex.DecodeString(blockHashRaw)
			if hexDecodeblockHashErr != nil {
				return hexDecodeblockHashErr
			}
			blockHash = [32]byte(intermediateblockHashLeaf[:32])

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := NodeInterfaceCallerSession{
				Contract: &contract.NodeInterfaceCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetL1Confirmations(
				blockHash,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %d\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&blockHashRaw, "block-hash", "", "block-hash argument")

	return cmd
}
func CreateL2BlockRangeForL1Command() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var blockNum uint64

	var capture0 struct {
		FirstBlock uint64
		LastBlock  uint64
	}

	cmd := &cobra.Command{
		Use:   "l-2-block-range-for-l-1",
		Short: "Call the L2BlockRangeForL1 view method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := NodeInterfaceCallerSession{
				Contract: &contract.NodeInterfaceCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.L2BlockRangeForL1(
				blockNum,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().Uint64Var(&blockNum, "block-num", 0, "block-num argument")

	return cmd
}

func CreateEstimateRetryableTicketCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var sender common.Address
	var senderRaw string
	var deposit *big.Int
	var depositRaw string
	var to0 common.Address
	var to0Raw string
	var l2CallValue *big.Int
	var l2CallValueRaw string
	var excessFeeRefundAddress common.Address
	var excessFeeRefundAddressRaw string
	var callValueRefundAddress common.Address
	var callValueRefundAddressRaw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "estimate-retryable-ticket",
		Short: "Execute the EstimateRetryableTicket method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if senderRaw == "" {
				return fmt.Errorf("--sender argument not specified")
			} else if !common.IsHexAddress(senderRaw) {
				return fmt.Errorf("--sender argument is not a valid Ethereum address")
			}
			sender = common.HexToAddress(senderRaw)

			if depositRaw == "" {
				return fmt.Errorf("--deposit argument not specified")
			}
			deposit = new(big.Int)
			deposit.SetString(depositRaw, 0)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if l2CallValueRaw == "" {
				return fmt.Errorf("--l-2-call-value argument not specified")
			}
			l2CallValue = new(big.Int)
			l2CallValue.SetString(l2CallValueRaw, 0)

			if excessFeeRefundAddressRaw == "" {
				return fmt.Errorf("--excess-fee-refund-address argument not specified")
			} else if !common.IsHexAddress(excessFeeRefundAddressRaw) {
				return fmt.Errorf("--excess-fee-refund-address argument is not a valid Ethereum address")
			}
			excessFeeRefundAddress = common.HexToAddress(excessFeeRefundAddressRaw)

			if callValueRefundAddressRaw == "" {
				return fmt.Errorf("--call-value-refund-address argument not specified")
			} else if !common.IsHexAddress(callValueRefundAddressRaw) {
				return fmt.Errorf("--call-value-refund-address argument is not a valid Ethereum address")
			}
			callValueRefundAddress = common.HexToAddress(callValueRefundAddressRaw)

			var hexDecodedataErr error

			data, hexDecodedataErr = hex.DecodeString(dataRaw)
			if hexDecodedataErr != nil {
				return hexDecodedataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := NodeInterfaceTransactorSession{
				Contract:     &contract.NodeInterfaceTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.EstimateRetryableTicket(
				sender,
				deposit,
				to0,
				l2CallValue,
				excessFeeRefundAddress,
				callValueRefundAddress,
				data,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&senderRaw, "sender", "", "sender argument")
	cmd.Flags().StringVar(&depositRaw, "deposit", "", "deposit argument")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument")
	cmd.Flags().StringVar(&l2CallValueRaw, "l-2-call-value", "", "l-2-call-value argument")
	cmd.Flags().StringVar(&excessFeeRefundAddressRaw, "excess-fee-refund-address", "", "excess-fee-refund-address argument")
	cmd.Flags().StringVar(&callValueRefundAddressRaw, "call-value-refund-address", "", "call-value-refund-address argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument")

	return cmd
}
func CreateGasEstimateComponentsCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var to0 common.Address
	var to0Raw string
	var contractCreation bool
	var contractCreationRaw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "gas-estimate-components",
		Short: "Execute the GasEstimateComponents method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			contractCreationRawLower := strings.ToLower(contractCreationRaw)
			switch contractCreationRawLower {
			case "true", "t", "y", "yes", "1":
				contractCreation = true
			case "false", "f", "n", "no", "0":
				contractCreation = false
			default:
				return fmt.Errorf("--contract-creation argument is not valid (value: %s)", contractCreationRaw)
			}

			var hexDecodedataErr error

			data, hexDecodedataErr = hex.DecodeString(dataRaw)
			if hexDecodedataErr != nil {
				return hexDecodedataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := NodeInterfaceTransactorSession{
				Contract:     &contract.NodeInterfaceTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.GasEstimateComponents(
				to0,
				contractCreation,
				data,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument")
	cmd.Flags().StringVar(&contractCreationRaw, "contract-creation", "", "contract-creation argument (true, t, y, yes, 1 OR false, f, n, no, 0)")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument")

	return cmd
}
func CreateGasEstimateL1ComponentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address

	var to0 common.Address
	var to0Raw string
	var contractCreation bool
	var contractCreationRaw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "gas-estimate-l-1-component",
		Short: "Execute the GasEstimateL1Component method on a NodeInterface contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if keyfile == "" {
				return fmt.Errorf("--keystore not specified")
			}

			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			contractCreationRawLower := strings.ToLower(contractCreationRaw)
			switch contractCreationRawLower {
			case "true", "t", "y", "yes", "1":
				contractCreation = true
			case "false", "f", "n", "no", "0":
				contractCreation = false
			default:
				return fmt.Errorf("--contract-creation argument is not valid (value: %s)", contractCreationRaw)
			}

			var hexDecodedataErr error

			data, hexDecodedataErr = hex.DecodeString(dataRaw)
			if hexDecodedataErr != nil {
				return hexDecodedataErr
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewNodeInterface(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := NodeInterfaceTransactorSession{
				Contract:     &contract.NodeInterfaceTransactor,
				TransactOpts: *transactionOpts,
			}

			transaction, transactionErr := session.GasEstimateL1Component(
				to0,
				contractCreation,
				data,
			)
			if transactionErr != nil {
				return transactionErr
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument")
	cmd.Flags().StringVar(&contractCreationRaw, "contract-creation", "", "contract-creation argument (true, t, y, yes, 1 OR false, f, n, no, 0)")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the NODE_INTERFACE_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the NODE_INTERFACE_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("NODE_INTERFACE_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreateNodeInterfaceCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "node-interface",
		Short: "Interact with the NodeInterface contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdViewLegacyLookupMessageBatchProof := CreateLegacyLookupMessageBatchProofCommand()
	cmdViewLegacyLookupMessageBatchProof.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewLegacyLookupMessageBatchProof)
	cmdViewNitroGenesisBlock := CreateNitroGenesisBlockCommand()
	cmdViewNitroGenesisBlock.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewNitroGenesisBlock)
	cmdViewBlockL1Num := CreateBlockL1NumCommand()
	cmdViewBlockL1Num.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewBlockL1Num)
	cmdViewConstructOutboxProof := CreateConstructOutboxProofCommand()
	cmdViewConstructOutboxProof.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewConstructOutboxProof)
	cmdViewFindBatchContainingBlock := CreateFindBatchContainingBlockCommand()
	cmdViewFindBatchContainingBlock.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewFindBatchContainingBlock)
	cmdViewGetL1Confirmations := CreateGetL1ConfirmationsCommand()
	cmdViewGetL1Confirmations.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetL1Confirmations)
	cmdViewL2BlockRangeForL1 := CreateL2BlockRangeForL1Command()
	cmdViewL2BlockRangeForL1.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewL2BlockRangeForL1)

	cmdTransactEstimateRetryableTicket := CreateEstimateRetryableTicketCommand()
	cmdTransactEstimateRetryableTicket.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactEstimateRetryableTicket)
	cmdTransactGasEstimateComponents := CreateGasEstimateComponentsCommand()
	cmdTransactGasEstimateComponents.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactGasEstimateComponents)
	cmdTransactGasEstimateL1Component := CreateGasEstimateL1ComponentCommand()
	cmdTransactGasEstimateL1Component.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactGasEstimateL1Component)

	return cmd
}

